<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.3.1">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2018-10-09T17:17:29+01:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Yohann’s Blog</title><subtitle>I'm gonna write down things I learned along with my understandings.</subtitle><author><name>Yuhang Ming</name><email>yuhang.ming@bristol.ac.uk</email></author><entry><title type="html">REVIEW: Semantic SLAM (Keep Updating)</title><link href="http://localhost:4000/review-semantic-SLAM/" rel="alternate" type="text/html" title="REVIEW: Semantic SLAM (Keep Updating)" /><published>2018-10-09T15:00:00+01:00</published><updated>2018-10-09T15:00:00+01:00</updated><id>http://localhost:4000/review-semantic-SLAM</id><content type="html" xml:base="http://localhost:4000/review-semantic-SLAM/">&lt;p&gt;Why higher level features are needed:&lt;/p&gt;

&lt;p&gt;More discriminative, which helps data association;&lt;/p&gt;

&lt;p&gt;Serve to inform robotic tasks that require higher level information.&lt;/p&gt;

&lt;h3 id=&quot;how-semantic-information-is-used&quot;&gt;HOW Semantic Information Is Used&lt;/h3&gt;

&lt;p&gt;&lt;u&gt;Objection Recognition&lt;/u&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Feature-Based Recognition&lt;/p&gt;

    &lt;p&gt;[12] proposes to use SURF features and reconstruct the object in a SfM manner.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use Pre-Defined Models&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;[1] builds models of objects using KinectFusion, and then 3D objects are detected by matching to these pre-defined models. The pipeline of the SLAM++ system is shown below.&lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;img src=&quot;\assets\img\posts\SLAM++.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;[3] doesn’t mention how the object detection is performed but the objects to be detected are limited to doors and red chairs only. So a reasonable guess is that the model of doors and red chairs are built before-hand and then perform 3D object detection.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Use Deep Learning Methods&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;[6] uses SLAM to help create accurate maps with objects. Due to the online requirements, the authors model objects as separate entities in space instead of generating object instances from point-wise labelling map. The objects are detected using Single Shot MultiBox Detector (SSD) and 3D segmentation is performed leveraging depth information.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;[7] proposes a more general setup of semantic SLAM which uses points, planes and objects. &lt;u&gt;This is the first real-time semantic SLAM system proposed in literature that uses previously unseen objects as landmarks&lt;/u&gt;. The authors use Faster-RCNN to perform object recognition and then instead of bounding boxes, ellipsoids are used to represent objects. The pipeline of the semantic point-plane-object SLAM system is shown below.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;

    &lt;p&gt;&lt;img src=&quot;\assets\img\posts\point-plane-object-SLAM.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;[8] also uses Faster-RCNN to detec objects and then a novel nonparametric pose graph that models data association and SLAM in a single framework.&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;u&gt;Semantic Segmentation&lt;/u&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Plane Segmentation&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;[5] considers all homogeneous planes as planar landmarks and the remaining non-planar regions as the regions corresponding to potential objects of interest. The ICP algorithm is then used to find matches between objects of interest. In this manner, no pre-defined object models are needed, and a dataset of objects as the system is running.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;[10] uses CNN to detect planes and then incorporating them into points-based LSD-SLAM to achieve better performance in low texture environment.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Scene Segmentation&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;[4] tackles the problem of medium-term continuous tracking. Patch / feature-point based tracking may fail due to severe scale variation, but if we have the information about the semantic identity of the patch / feature-point, we can still perform correct matching. Meaning that although the patch appearance changes drastically, its semantic identity remains the same, for example from the same vehicle.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;[9] aims to improve SLAM performance in the dynamic environments. The authors incorporate the semantic information with optical flow to determine whether the object is moving. Given results from pixel-wise semantic segmentation and moving consistency check, the authors decide if an object is moving based on the following criteria: if the number of dynamic points producedby moving consistency check fall in the contours of a segmented object is larger than a specific threshold, then this object is determined to be moving. If the segmented object is determined to be moving, then all the feature points located in the object’s contour is considered as outlier and will be removed.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;[11] proposes that the error in outdoor-senario tracking is most likely caused by sky-region and car-region, based on its empirical studies. So the authors propose to use DNN to segment these regions out of the input image, by using a mask, and then perform ORB-SLAM on the rest regions of the image.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;how-optimization-is-performed&quot;&gt;HOW Optimization Is Performed&lt;/h3&gt;

&lt;h3 id=&quot;how-the-map-is-built&quot;&gt;HOW The Map Is Built&lt;/h3&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference:&lt;/h3&gt;

&lt;p&gt;[1] R. F. Salas-Moreno, R. A. Newcombe, H. Strasdat, P. H. J. Kelly, and A. J. Davison. “SLAM++: Simultaneous Local- isation and Mapping at the Level of Objects”. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2013.&lt;/p&gt;

&lt;p&gt;[2] M. Bloesch, J. Czarnowski, R. Clark, S. Leutenegger, and A. J. Davison. “CodeSLAM - Learning a Compact, Optimisable Representation for Dense Visual SLAM”. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2018.&lt;/p&gt;

&lt;p&gt;[3] S. L. Bowman, N. Atanasov, K. Daniilidis, and G. J. Pappas. “Probabilistic Data Association for Semantic SLAM”. IEEE/RSJ International Conference on Robotics and Automation (ICRA), 2017.&lt;/p&gt;

&lt;p&gt;[4] K. Lianos, J. L. Schönberger, M. Pollefeys, and T. Sattler. “VSO: Visual Semantic Odometry”. European Conference on Computer Vision (ECCV), 2018.&lt;/p&gt;

&lt;p&gt;[5] S. Choudhary, A. J. B. Trevor, H. I. Christensen, and F. Dellaert. “SLAM with Object Discovery, Modeling and Mapping” IEEE/RSJ International Conference on Intelligent Robotics and Systems (IROS), 2014.&lt;/p&gt;

&lt;p&gt;[6] N. Sünderhauf, T. T. Pham, Y. Latif, M. Milford, and I. Reid. “Meaningful Maps with Object-Oriented Semantic Mapping”. IEEE/RSJ International Conference on Intelligent Robotics and Systems (IROS), 2017.&lt;/p&gt;

&lt;p&gt;[7] M. Hosseinzadeh, Y. Latif, T. Pham, N. Sünderhauf, and I. Reid. “Towards Semantic SLAM: Points, Planes and Objects”. IEEE/RSJ International Conference on Intelligent Robotics and Systems (IROS), 2017.&lt;/p&gt;

&lt;p&gt;[8] B. Mu, S. Liu, L. Paull, J. Leonard, and J. P. How. “SLAM with Objects using a Nonparametric Pose Graph”. IEEE/RSJ International Conference on Intelligent Robotics and Systems (IROS), 2016.&lt;/p&gt;

&lt;p&gt;[9] C. Yu, Z. Liu, X. Liu, F. Xie, Y. Yang, Q. Wei, and Q. Fei. “DS-SLAM: A Semantic Visual SLAM Towards Dynamic Environments”. IEEE/RSJ International Conference on Intelligent Robotics and Systems (IROS), 2018.&lt;/p&gt;

&lt;p&gt;[10] S. Yang, Y. Song, M. Kaess, adn S. Scherer. “Pop-up SLAM: Semantic Monocular Plane SLAM for Low-texture Environments”. arXiv, 2017.&lt;/p&gt;

&lt;p&gt;[11] M. Kaneko, K. Iwami, T. Ogawa, T. Yamasaki, and K. Aizawa. “Mask-SLAM: Robust Feature-Based Monocular SLAM by Masking Using Semantic Segmentation”. In Proceedings of the IEEE Conference on Computer Vision and Pattern Recognition (CVPR), 2018.&lt;/p&gt;

&lt;p&gt;[12] J. Civera, D. Gálvez-López, L. Riazuelo, J. D. Tardós, and J. M. M. Montiel. “Towards Semantic SLAM Using a Monocular Camera”. IEEE/RSJ International Conference on Robotics and Automation (ICRA), 2011.&lt;/p&gt;

&lt;h3 id=&quot;appendix&quot;&gt;Appendix&lt;/h3&gt;</content><author><name>Yuhang Ming</name><email>yuhang.ming@bristol.ac.uk</email></author><summary type="html">Why higher level features are needed:</summary></entry><entry><title type="html">Graph-Based SLAM</title><link href="http://localhost:4000/graph-based-SLAM/" rel="alternate" type="text/html" title="Graph-Based SLAM" /><published>2018-10-07T19:17:00+01:00</published><updated>2018-10-07T19:17:00+01:00</updated><id>http://localhost:4000/graph-based-SLAM</id><content type="html" xml:base="http://localhost:4000/graph-based-SLAM/">&lt;h3 id=&quot;probabilistic-formulation&quot;&gt;Probabilistic Formulation:&lt;/h3&gt;

&lt;p&gt;Along a trajectory, given:&lt;/p&gt;

&lt;p&gt;-&amp;gt; A series of camera poses: &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x_{1:T}} = \{ \boldsymbol{x_1}, \dots, \boldsymbol{x_T} \}&lt;/script&gt;;&lt;/p&gt;

&lt;p&gt;-&amp;gt; A series of measurements from motion sensors (like wheel odometry or IMU): &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{u_{1:T}} = \{ \boldsymbol{u_1}, \dots, \boldsymbol{u_T} \}&lt;/script&gt;;&lt;/p&gt;

&lt;p&gt;-&amp;gt; A series of perceptions of the environment (the landmarks observed by the camera at each time step): &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{z_{1:T}} = \{ \boldsymbol{z_1}, \dots, \boldsymbol{z_T} \}&lt;/script&gt;;&lt;/p&gt;

&lt;p&gt;-&amp;gt; A map of the environment &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{m}&lt;/script&gt; which consists of &lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; landmarks &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{l_{1:N}} = \{ \boldsymbol{l_1}, \dots, \boldsymbol{l_N} \}&lt;/script&gt;;&lt;/p&gt;

&lt;p&gt;The SLAM problem can be formulated as:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Estimating the posterior probability of the trajectory&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x_{1:T}}&lt;/script&gt; &lt;em&gt;and the map&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{m}&lt;/script&gt; &lt;em&gt;given all the measurements plus an initial pose&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x_0}&lt;/script&gt;.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;p(\boldsymbol{x_{1:T}}, \boldsymbol{m} \vert \boldsymbol{z_{1:T}}, \boldsymbol{u_{1:T}}, \boldsymbol{x_0})&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;dynamic-bayesian-network-dbn&quot;&gt;Dynamic Bayesian Network (DBN)&lt;/h3&gt;

&lt;p&gt;DBN describs a stochastic process as a directed graph where an arrow in the graph indicats the dependency between two nodes. E.g. an arrow pointed from &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x_0}&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x_1}&lt;/script&gt; means &lt;script type=&quot;math/tex&quot;&gt;p(\boldsymbol{x_1} \vert \boldsymbol{x_0})&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\img\posts\DBN.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Expressing SLAM as a DBN highlights its temporal structure. Hence this formulization is well-suited for the filtering processes that can be used to tackle SLAM problems via the MAP (Maximize-A-Posterior) scheme.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\{ \boldsymbol{x}, \boldsymbol{l} \}^* = \mathrm{argmax}(\boldsymbol{x_0}) \prod P(\boldsymbol{x_k} \vert \boldsymbol{x_{k-1}, \boldsymbol{u_k}}) \prod P(\boldsymbol{z_k} \vert \boldsymbol{x_i}, \boldsymbol{l_j})&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;graph-based--network-based-formulation&quot;&gt;Graph-Based / Network-Based Formulation&lt;/h3&gt;

&lt;p&gt;This formulation highlights the underlying spatial structure of the SLAM system. This is usually divided into a 2-step tast: 1. constructing the graph from raw measurements (front-end); 2. determining the MOST LIKELY configuration of the poses given constraints (edges) of the graph.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Data Association [Front-End]&lt;/p&gt;

    &lt;p&gt;An edge between 2 nodes is labelled with a probatility distribution over teh relative transformation of 2 poses, conditioned on their mutual measurements. One needs to determine the Most Likely constraint resulting from an observation. More details about probablistic data association refer to [3].&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\mathcal{D}_{t, t+1} = \underset{\mathcal{D}}{\mathrm{argmax}} \, p(\mathcal{D} \vert \boldsymbol{x_0}, \boldsymbol{z_{t, t+1}}, \boldsymbol{u_{t, t+1}})&lt;/script&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Graph-Based Mapping [Back-End]&lt;/p&gt;

    &lt;p&gt;&lt;em&gt;Assuming that Gaussian noise is added to the observations and the data association is known. The GOAL is to find a Gaussian approximation of the posterior over the trajectory.&lt;/em&gt;&lt;/p&gt;

    &lt;p&gt;First some new notations are introduced here:&lt;/p&gt;

    &lt;p&gt;-&amp;gt; let &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x} = (\boldsymbol{x_1}, \dots, \boldsymbol{x_T})^T&lt;/script&gt; be the vector of parameters where &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x_i}&lt;/script&gt; stands for the pose of node &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt;;&lt;/p&gt;

    &lt;p&gt;-&amp;gt; let the noise be zero-mean Gaussian with information matrix &lt;script type=&quot;math/tex&quot;&gt;\Omega_{ij}&lt;/script&gt;, so the transformation that makes the observation acquired from &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; maximally overlap with overvation acquired form &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; follows the Gaussian distribution &lt;script type=&quot;math/tex&quot;&gt;\mathcal{N}(T_{ij}, \Omega_{ij}^{-1})&lt;/script&gt;;&lt;/p&gt;

    &lt;p&gt;-&amp;gt; let &lt;script type=&quot;math/tex&quot;&gt;\hat{T_{ij}}(\boldsymbol{x_i}, \boldsymbol{x_j})&lt;/script&gt; be the prediction transformation between node &lt;script type=&quot;math/tex&quot;&gt;i&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;j&lt;/script&gt; (note that this is a random variable).&lt;/p&gt;

    &lt;p&gt;Therefore, we have the distribution of the random variable &lt;script type=&quot;math/tex&quot;&gt;\hat{T_{ij}}&lt;/script&gt;:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;P_T( \hat{T_{ij}} ) = \frac{ \mathrm{exp} (-\frac{1}{2} (\hat{T_{ij}} - T_{ij})^T \Omega_{ij} (\hat{T_{ij}} - T_{ij})) }{\sqrt{ (2\pi)^k \vert\Sigma_{ij}\vert }}&lt;/script&gt;

    &lt;p&gt;assuming that &lt;script type=&quot;math/tex&quot;&gt;\hat{T_{ij}}&lt;/script&gt; is a &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; dimensional vector. Then, the negative log-likelihood is&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathcal{L}_{ij} \propto (T_{ij} - \hat{T_{ij}})^T \Omega_{ij} (T_{ij} - \hat{T_{ij}})&lt;/script&gt;

    &lt;p&gt;By defining &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{e_{ij}} = \boldsymbol{e_{ij}}(\boldsymbol{x_i}, \boldsymbol{x_j}) = T_{ij} - \hat{T_{ij}}&lt;/script&gt;, we have the final objective function:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\boldsymbol{\mathrm{F}}(\boldsymbol{x}) = \sum_{&lt;i, j&gt; \in C} \boldsymbol{e_{ij}}^T \Omega_{ij} \boldsymbol{e_{ij}} %]]&gt;&lt;/script&gt;

    &lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;C&lt;/script&gt; is the set of pairs of indices for which a constraint (ovservation) exits. Under the MLE scheme, we can find the optimal values for &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x}&lt;/script&gt; by:&lt;/p&gt;

    &lt;table&gt;
      &lt;tbody&gt;
        &lt;tr&gt;
          &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x}^* = \underset{\boldsymbol{x}}{\mathrm{argmin}} \, \boldsymbol{\mathrm{F}}(\boldsymbol{x})&lt;/script&gt;&lt;/td&gt;
        &lt;/tr&gt;
      &lt;/tbody&gt;
    &lt;/table&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Solving for The Optimal&lt;/p&gt;

    &lt;p&gt;Given a good initial guess of the poses &lt;script type=&quot;math/tex&quot;&gt;\breve{\boldsymbol{x}}&lt;/script&gt;, usually can be obtained using linear estimation like SVD, the numerical solution of &lt;script type=&quot;math/tex&quot;&gt;\underset{\boldsymbol{x}}{\mathrm{argmin}} \, \boldsymbol{\mathrm{F}}(\boldsymbol{x})&lt;/script&gt; can be found using following methods:&lt;/p&gt;

    &lt;ol&gt;
      &lt;li&gt;
        &lt;p&gt;First-order and Second-order Gradient Descent&lt;/p&gt;

        &lt;p&gt;The most straight-forward way is performing Taylor expansion around the initial guess &lt;script type=&quot;math/tex&quot;&gt;\breve{\boldsymbol{x}}&lt;/script&gt;, we have:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{split}
  &amp; \boldsymbol{x}^* = \underset{\boldsymbol{x}}{\mathrm{argmin}} \, \boldsymbol{\mathrm{F}} (\boldsymbol{x}) \\
  \Rightarrow \quad
  &amp; \breve{\boldsymbol{x}} + \Delta\boldsymbol{x}^* = \underset{\Delta\boldsymbol{x}}{\mathrm{argmin}} \, \boldsymbol{\mathrm{F}} (\breve{\boldsymbol{x}} + \Delta\boldsymbol{x})
\end{split} %]]&gt;&lt;/script&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{split}
  \boldsymbol{\mathrm{F_{ij}}}(\breve{\boldsymbol{x_i}} + \Delta\boldsymbol{x_i}, \breve{\boldsymbol{x_j}} + \Delta\boldsymbol{x_j}) 
  &amp;= \boldsymbol{\mathrm{F_{ij}}}(\breve{\boldsymbol{x}} + \Delta\boldsymbol{x}) \\
  &amp;= \boldsymbol{e_{ij}}^T \Omega_{ij} \boldsymbol{e_{ij}} \\
  &amp;\simeq \boldsymbol{\mathrm{F_{ij}}}(\breve{\boldsymbol{x}}) + \boldsymbol{J} \Delta\boldsymbol{x} + \frac{1}{2} \Delta\boldsymbol{x}^T\boldsymbol{H}\Delta\boldsymbol{x}
\end{split} %]]&gt;&lt;/script&gt;

        &lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{J}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{H}&lt;/script&gt; are the Jacobian matrix and Hessian matrix of &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{\mathrm{F_{ij}}}&lt;/script&gt;. To find minimum, simply take derivative w.r.t. &lt;script type=&quot;math/tex&quot;&gt;\Delta\boldsymbol{x}&lt;/script&gt; and set the equation equal to 0.&lt;/p&gt;

        &lt;p&gt;When keeping first-order gradient only, we have &lt;strong&gt;Steepst Descent Method&lt;/strong&gt;, with&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta\boldsymbol{x}^* = -\boldsymbol{J}^T(\breve{\boldsymbol{x}})&lt;/script&gt;

        &lt;p&gt;When keeping the additional second-order gradient, we have &lt;strong&gt;Newton Method&lt;/strong&gt;, with&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{H}\Delta\boldsymbol{x} = -\boldsymbol{J}^T&lt;/script&gt;

        &lt;p&gt;&lt;em&gt;Problems with&lt;/em&gt;&lt;/p&gt;

        &lt;p&gt;-&amp;gt; Steepest Descent Method: too greedy, leaning to zig-zag desent;&lt;/p&gt;

        &lt;p&gt;-&amp;gt; Newton Method: huge computation complexity when calculating Hessian.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Gauss-Newton Method&lt;/p&gt;

        &lt;p&gt;To avoid the computation complexity when calculating Hessian, we tried to use first-order gradient (Jacobian) to approximate second-order gradient (Hessian). To begin with, we take Taylor expansion of the error term around the initial guess &lt;script type=&quot;math/tex&quot;&gt;\breve{\boldsymbol{x}}&lt;/script&gt;:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}} + \Delta\boldsymbol{x}) \simeq \boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + \boldsymbol{J_{ij}}\Delta\boldsymbol{x}&lt;/script&gt;

        &lt;p&gt;Then substituting the error term back into the objective funciton, we have the new objective function:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{split}
 &amp; \Delta\boldsymbol{x}^* = \underset{\Delta\boldsymbol{x}}{\mathrm{argmin}} \, \boldsymbol{\mathrm{F}} (\breve{\boldsymbol{x}} + \Delta\boldsymbol{x}) \\
 \Rightarrow \quad
 &amp; \Delta\boldsymbol{x}^* = \underset{\Delta\boldsymbol{x}}{\mathrm{argmin}} \, \sum_{&lt;i, j&gt; \in C} (\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + \boldsymbol{J_{ij}}\Delta\boldsymbol{x})^T \Omega_{ij} (\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + \boldsymbol{J_{ij}}\Delta\boldsymbol{x})
\end{split} %]]&gt;&lt;/script&gt;

        &lt;p&gt;after expanding and combining terms, we have:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{split}
  \boldsymbol{\mathrm{F_{ij}}}(\breve{\boldsymbol{x}} + \Delta\boldsymbol{x}) 
  &amp;= \boldsymbol{e_{ij}}(\breve{\boldsymbol{x}} + \Delta\boldsymbol{x})^T \Omega_{ij} \boldsymbol{e_{ij}}(\breve{\boldsymbol{x}} + \Delta\boldsymbol{x}) \\
  &amp;\simeq (\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + \boldsymbol{J_{ij}}\Delta\boldsymbol{x})^T \Omega_{ij} (\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + \boldsymbol{J_{ij}}\Delta\boldsymbol{x}) \\
  &amp;= \boldsymbol{e_{ij}}(\breve{\boldsymbol{x}})^T\Omega_{ij}\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + 2\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}})^T\Omega_{ij}\boldsymbol{J_{ij}}\Delta\boldsymbol{x} + \Delta\boldsymbol{x}^T\boldsymbol{J_{ij}}^T\Omega_{ij}\boldsymbol{J_{ij}}\Delta\boldsymbol{x}
\end{split} %]]&gt;&lt;/script&gt;

        &lt;p&gt;Again, to find the optimal, we take derivative w.r.t. &lt;script type=&quot;math/tex&quot;&gt;\Delta\boldsymbol{x}&lt;/script&gt; and set the equation equal to 0, we have:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{split}
  &amp; \boldsymbol{e_{ij}}(\breve{\boldsymbol{x}})^T\Omega_{ij}\boldsymbol{J_{ij}} + \boldsymbol{J_{ij}}^T\Omega_{ij}\boldsymbol{J_{ij}}\Delta\boldsymbol{x} = \boldsymbol{0} \\
  \Rightarrow \quad
  &amp; \boldsymbol{J_{ij}}^T\Omega_{ij}\boldsymbol{J_{ij}}\Delta\boldsymbol{x} = -\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}})^T\Omega_{ij}\boldsymbol{J_{ij}}
\end{split} %]]&gt;&lt;/script&gt;

        &lt;p&gt;Let &lt;script type=&quot;math/tex&quot;&gt;\,\boldsymbol{H} = \boldsymbol{J_{ij}}^T\Omega_{ij}\boldsymbol{J_{ij}}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\,\boldsymbol{g} = -\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}})^T\Omega_{ij}\boldsymbol{J_{ij}}&lt;/script&gt;,&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{H}\Delta\boldsymbol{x} = \boldsymbol{g}&lt;/script&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;p&gt;which is called &lt;strong&gt;Augmented Equation&lt;/strong&gt;, a.k.a. Gauss Newton Equation or Normal Equation.&lt;/p&gt;

        &lt;p&gt;&lt;strong&gt;Solving the augmented equation is the core of the optimization.&lt;/strong&gt; The complete optimization algorithm is:&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;i. Calculate the initial guess&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\,\breve{\boldsymbol{x}}&lt;/script&gt;;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;ii. For kth iteration, calculate Jacobian matrix and the error term&lt;/em&gt;;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;iii. Sovle the augmented equation&lt;/em&gt;;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;iv. If&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\,\Delta\boldsymbol{x_k}\,&lt;/script&gt; &lt;em&gt;is small enough, stop; else,&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\,\Delta\boldsymbol{x_{k+1}} = \boldsymbol{x_k} + \Delta\boldsymbol{x_k}&lt;/script&gt;.&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;Problems with&lt;/em&gt; Gauss-Newton: &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{H}&lt;/script&gt; should be positive definite while &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{J}^T\Omega\boldsymbol{J}&lt;/script&gt; is positive semi-definite (may be a singular matrix or in ill-condition); the algorithm may not converge due to the unstable augmented value.&lt;/p&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Levenberg-Marquardt Method&lt;/p&gt;

        &lt;p&gt;To get a better approximation of the Hessian matrix, a Trust Region &lt;script type=&quot;math/tex&quot;&gt;\mu&lt;/script&gt; is added to the &lt;script type=&quot;math/tex&quot;&gt;\Delta\boldsymbol{x}&lt;/script&gt;. The new objective function is defined as:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta\boldsymbol{x}^* = \underset{\Delta\boldsymbol{x}}{\mathrm{argmin}} \, \sum (\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + \boldsymbol{J_{ij}}\Delta\boldsymbol{x})^T \Omega_{ij} (\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + \boldsymbol{J_{ij}}\Delta\boldsymbol{x}), \,\, s.t. \,\, || D\Delta\boldsymbol{x} ||^2 \leq \mu&lt;/script&gt;

        &lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt; can either be identity or tha square root of the diagonal elements from &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{J}^T\boldsymbol{J}&lt;/script&gt;. Using Lagrange multipliers and, again, looking at one pair, we have:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\Delta\boldsymbol{x}^* = \underset{\Delta\boldsymbol{x}}{\mathrm{argmin}} \, (\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + \boldsymbol{J_{ij}}\Delta\boldsymbol{x})^T \Omega_{ij} (\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}}) + \boldsymbol{J_{ij}}\Delta\boldsymbol{x}) + \frac{\lambda}{2} || D\Delta\boldsymbol{x} ||^2&lt;/script&gt;

        &lt;p&gt;Similarly, we have the augmented equation:&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;(\boldsymbol{H} + \lambda D^TD) \Delta\boldsymbol{x} = \boldsymbol{g}&lt;/script&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;p&gt;Setting &lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt; to identity (for simplicity),&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;(\boldsymbol{H} + \lambda I) \Delta\boldsymbol{x} = \boldsymbol{g}&lt;/script&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;p&gt;To view the L-M algorithm from another angle, we can see that the L-M algorithm adaptively varies the parameter updates between the gradient descent update and the Gauss-Newton update. When &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt; is relatively small, &lt;script type=&quot;math/tex&quot;&gt;(\boldsymbol{H} + \lambda I) \rightarrow \boldsymbol{H}&lt;/script&gt;, meaning the approximation is acceptable, L-M algorithm is more like G-N; when &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt; is relatively large, &lt;script type=&quot;math/tex&quot;&gt;(\boldsymbol{H} + \lambda I) \rightarrow \lambda I&lt;/script&gt;, meaning the approximation is not good enough, L-M is more like steepest descent. Details discussion can be found in &lt;a href=&quot;http://www.ananth.in/docs/lmtut.pdf&quot;&gt; L-M &lt;/a&gt;.&lt;/p&gt;

        &lt;p&gt;To find the range of trust region, we define:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\rho = \frac{\boldsymbol{e_{ij}}(\breve{\boldsymbol{x}} + \Delta\boldsymbol{x}) - \boldsymbol{e_{ij}}(\breve{\boldsymbol{x}})}{\boldsymbol{J}(\breve{\boldsymbol{x}}) \Delta\boldsymbol{x}}&lt;/script&gt;

        &lt;p&gt;-&amp;gt; &lt;script type=&quot;math/tex&quot;&gt;\rho \, \rightarrow \, 1&lt;/script&gt;, meaning the approximation is good;&lt;/p&gt;

        &lt;p&gt;-&amp;gt; &lt;script type=&quot;math/tex&quot;&gt;\rho&lt;/script&gt; is too small, meaning the real descent is far smaller than the approximated descent, the range needs to be narrowed down;&lt;/p&gt;

        &lt;p&gt;-&amp;gt; &lt;script type=&quot;math/tex&quot;&gt;\rho&lt;/script&gt; is too large, meaning the real descent is far larger than the approximated descent, the range needs to be expanded.&lt;/p&gt;

        &lt;p&gt;Finally, the complete algorithm is:&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;i. Calculate the initial guess&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\,\breve{\boldsymbol{x}} \,&lt;/script&gt; &lt;em&gt;and the initial range of trust region&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\mu&lt;/script&gt;;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;ii. Calculate the Jacobian matrix and the error term, solve for the augmented equation&lt;/em&gt;;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;iii. Compute&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\, \rho&lt;/script&gt;;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;iv. If&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\, \rho &gt; 0.75, \quad \mu = 2\mu&lt;/script&gt;;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;v. If&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\, \rho &lt; 0.25, \quad \mu = 0.5\mu %]]&gt;&lt;/script&gt;;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;vi. If&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\, \rho \,&lt;/script&gt; &lt;em&gt;is greater than some threshold, then we consider the approximation is acceptable,&lt;/em&gt; &lt;script type=&quot;math/tex&quot;&gt;\,\Delta\boldsymbol{x_{k+1}} = \boldsymbol{x_k} + \Delta\boldsymbol{x_k}&lt;/script&gt;;&lt;/p&gt;

        &lt;p&gt;&lt;em&gt;vii. Decide if the algorithm converge, return to step ii if not converge&lt;/em&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference:&lt;/h3&gt;

&lt;p&gt;[1] 高翔；张涛；刘毅；严沁睿: “视觉SLAM十四讲，从理论到实践”.&lt;/p&gt;

&lt;p&gt;[2] G. Grisetti, R. Kümmerle, C. Stachniss, and W. Burgard. “A Tutorial on Graph-Based SLAM”. IEEE Intelligent Transportation Systems Magazine. 2(4):31-43, December 2010.&lt;/p&gt;

&lt;p&gt;[3] S. Bowman, N. Atanasov, K. Daniilidis, and G. Pappas. “Probabilistic Data Association for Semantic SLAM”. IEEE International Conference on Robotics and Automation (ICRA). May 2017.&lt;/p&gt;

&lt;h3 id=&quot;appendix&quot;&gt;Appendix&lt;/h3&gt;</content><author><name>Yuhang Ming</name><email>yuhang.ming@bristol.ac.uk</email></author><summary type="html">Probabilistic Formulation:</summary></entry><entry><title type="html">Iterative Closest Point</title><link href="http://localhost:4000/ICP/" rel="alternate" type="text/html" title="Iterative Closest Point" /><published>2018-09-30T18:00:00+01:00</published><updated>2018-09-30T18:00:00+01:00</updated><id>http://localhost:4000/ICP</id><content type="html" xml:base="http://localhost:4000/ICP/">&lt;h3 id=&quot;usage&quot;&gt;Usage:&lt;/h3&gt;

&lt;p&gt;In SLAM systems, the ICP algorithm is usually used in the front-end, i.e. visual odometry, for 3D-3D pose estimation.&lt;/p&gt;

&lt;h3 id=&quot;problem-setup&quot;&gt;Problem Setup:&lt;/h3&gt;

&lt;p&gt;Given 2 sets of matched 3D points (assuming that we already matched 2 RGB-D images, details refering to the problem known as &lt;em&gt;data association / point matching / correspondence finding&lt;/em&gt;):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{P} = \{\boldsymbol{p}_1, \boldsymbol{p}_2, \dots, \boldsymbol{p}_n\}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{P}' = \{\boldsymbol{p}'_1, \boldsymbol{p}'_2, \dots, \boldsymbol{p}'_n\}&lt;/script&gt;

&lt;p&gt;We would like to find a transformation &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{R}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{t}&lt;/script&gt;, such that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall i, \boldsymbol{p}_i = \boldsymbol{R}\boldsymbol{p}'_i + \boldsymbol{t}&lt;/script&gt;

&lt;p&gt;ps. inhomogeneous coordinates are used here and below.&lt;/p&gt;

&lt;h3 id=&quot;solutions&quot;&gt;Solutions:&lt;/h3&gt;

&lt;p&gt;Before diving into the solutions, we should notice that camera model (intrinsic and extrinsic parameters of the camera) is not quite relevant when trying to find the transformation between 2 sets of 3D points.&lt;/p&gt;

&lt;p&gt;In order to find the desired transformation, we first formulate this problem in the least square manner:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{R}^*, \boldsymbol{t}^* = \underset{ \boldsymbol{R}, \boldsymbol{t} } {\mathrm{argmin}} \frac{1}{2} \sum_{i=1}^n \parallel \boldsymbol{p}_i - (\boldsymbol{R}\boldsymbol{p}'_i + \boldsymbol{t})  \parallel^2&lt;/script&gt;

&lt;p&gt;Like any other least square problems, there are 2 methods of finding the optimal transformation: Linear Estimation and Non-Linear Optimization.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Linear Estimation&lt;/p&gt;

    &lt;p&gt;The most popular linear estimation method is Singular Value Decomposition (SVD), which is discussed thoroughly in &lt;u&gt;Appendix 1&lt;/u&gt;. Here we focus on how SVD can be used to solve the optimal transformation.&lt;/p&gt;

    &lt;ul&gt;
      &lt;li&gt;
        &lt;p&gt;Reduce the number of parameters&lt;/p&gt;

        &lt;p&gt;Optimizing over 2 parameters is more difficult than optimizing over only 1 parameter. Therefore, we first reduce the number parameters in this least square problem.&lt;/p&gt;

        &lt;p&gt;By defining the centroids of each set of the points:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{p} = \frac{1}{2} \sum_{i=1}^n \boldsymbol{p_i}, \quad \boldsymbol{p}' = \frac{1}{2} \sum_{i=1}^n \boldsymbol{p_i}'&lt;/script&gt;

        &lt;p&gt;the least square term can now be expressed as below with mathematical details in &lt;u&gt;Appendix 2&lt;/u&gt;:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^n \parallel \boldsymbol{p_i} - (\boldsymbol{R}\boldsymbol{p_i}' + \boldsymbol{t}) \parallel^2 = \sum_{i=1}^n \parallel \boldsymbol{p_i} - \boldsymbol{p} - \boldsymbol{R}(\boldsymbol{p_i}' - \boldsymbol{p}') \parallel^2 + \parallel \boldsymbol{p} - \boldsymbol{R}\boldsymbol{p}' - \boldsymbol{t} \parallel^2&lt;/script&gt;

        &lt;p&gt;let &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{q_i} = \boldsymbol{p_i} - \boldsymbol{p}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{q_i}' = \boldsymbol{p_i}' - \boldsymbol{p}'&lt;/script&gt;, we have&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\underset{ \boldsymbol{R}, \boldsymbol{t} }{\mathrm{argmin}} \frac{1}{2} \sum_{i=1}^n \parallel \boldsymbol{p_i} - (\boldsymbol{R}\boldsymbol{p_i}' + \boldsymbol{t}) \parallel^2 = \underset{ \boldsymbol{R}, \boldsymbol{t} }{\mathrm{argmin}} \frac{1}{2} \sum_{i=1}^n \parallel \boldsymbol{q_i} - \boldsymbol{R}\boldsymbol{q_i}' \parallel^2 + \parallel \boldsymbol{p} - \boldsymbol{R}\boldsymbol{p}' - \boldsymbol{t} \parallel^2&lt;/script&gt;

        &lt;p&gt;Noticing that the first term of the R.H.S. is irrelavent of 
&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{t}&lt;/script&gt;
, so we can find the 
&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{R}^*&lt;/script&gt; 
by&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{R}^* = \underset{ \boldsymbol{R} }{\mathrm{argmin}} \frac{1}{2} \sum_{i=1}^n \parallel \boldsymbol{q_i} - \boldsymbol{R}\boldsymbol{q_i}' \parallel ^2&lt;/script&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;p&gt;and then calculate 
&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{t}^*&lt;/script&gt; 
by setting the second term to be zero, i.e.&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{t}^* = \boldsymbol{p} - \boldsymbol{R}^* \boldsymbol{p}'&lt;/script&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;
      &lt;/li&gt;
      &lt;li&gt;
        &lt;p&gt;Find &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{R}^*&lt;/script&gt;&lt;/p&gt;

        &lt;p&gt;Expanding equation &lt;script type=&quot;math/tex&quot;&gt;\frac{1}{2} \sum_{i=1}^n \parallel \boldsymbol{q_i} - \boldsymbol{R}\boldsymbol{q_i}' \parallel ^2&lt;/script&gt; we have&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{1}{2} \sum_{i=1}^n \boldsymbol{q_i}^T \boldsymbol{q_i} + \boldsymbol{q_i}'^T \boldsymbol{R}^T \boldsymbol{R} \boldsymbol{q_i}' - 2 \boldsymbol{q_i}^T \boldsymbol{R} \boldsymbol{q_i}'&lt;/script&gt;

        &lt;p&gt;Due to the orthogonality of the rotation matrix, i.e. &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{R}^T \boldsymbol{R} = \boldsymbol{I}&lt;/script&gt;, both the first 2 terms are irrelavant to &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{R}&lt;/script&gt;. Hence the least square problem becomes:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{R}^* = \underset{ \boldsymbol{R} }{\mathrm{argmax}} \frac{1}{2} \sum_{i=1}^n \boldsymbol{q_i}^T \boldsymbol{R} \boldsymbol{q_i}'&lt;/script&gt;

        &lt;p&gt;now we try to isolate &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{R}&lt;/script&gt; out of the summation (mathematical details can be found in &lt;u&gt;Appendix 3&lt;/u&gt;:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^n \boldsymbol{q_i}^T \boldsymbol{R} \boldsymbol{q_i}' = tr(\boldsymbol{R} \sum_{i=1}^n \boldsymbol{q_i}' \boldsymbol{q_i}^T)&lt;/script&gt;

        &lt;p&gt;By defining matrix &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{H} = \sum_{i=1}^n \boldsymbol{q_i}' \boldsymbol{q_i}^T&lt;/script&gt;, we can find the optimal rotation matrix by performing SVD on &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{H}&lt;/script&gt;:&lt;/p&gt;

        &lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{H} = \boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T&lt;/script&gt;

        &lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{\Sigma}&lt;/script&gt; is a diagonal matrix with nonnegative sigular values in descending order, and &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{U}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{V}&lt;/script&gt; are both orthonormal matrices. When &lt;script type=&quot;math/tex&quot;&gt;det(\boldsymbol{H}) = 1&lt;/script&gt;, we have,&lt;/p&gt;

        &lt;table&gt;
          &lt;tbody&gt;
            &lt;tr&gt;
              &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{R}^* = \boldsymbol{V}\boldsymbol{U}^T&lt;/script&gt;&lt;/td&gt;
            &lt;/tr&gt;
          &lt;/tbody&gt;
        &lt;/table&gt;

        &lt;p&gt;Mathematical details about the optimality can be found in &lt;u&gt;Appendix 4&lt;/u&gt;.&lt;/p&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Non-Linear Optimization&lt;/p&gt;

    &lt;p&gt;Non-Linear optimization method can solve for the optimal transformation in an interative manner.&lt;/p&gt;

    &lt;p&gt;&lt;u&gt;Details To Be Added...&lt;/u&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;slam&quot;&gt;SLAM++:&lt;/h3&gt;

&lt;p&gt;SLAM++ uses a fast dense ICP algorithm proposed in [3], which uses a &lt;em&gt;projection-based algorithm to generate point correspondences combined with a point-to-plane error metric and the standard “select-match-minimize” ICP iteration, along with random sampling, constant weighting, and a distance threshold for rejecting pairs&lt;/em&gt;.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Compute a reference view prediction&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
  \mathrm{Depth} \, \mathrm{Map} \, D_r \\
  \mathrm{Normal} \, \mathrm{Map} \,  N_r
\end{cases}&lt;/script&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\rightarrow \mathrm{estimated} \, \mathrm{frame} \, \mathrm{pose} \, T_{wr} (\mathrm{6-DoF})&lt;/script&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Point-to-plane error metric&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
  E_c(\boldsymbol{x}) = \underset{u \in \Omega}{\sum} \psi (e(u, \boldsymbol{x})) \\
  e(u, \boldsymbol{x}) = N_r(u')^T (exp(\boldsymbol{x}) \hat{v_l}(u) - v_r(u')) \\
  \hat{v_l}(u) = \tilde{T_{rl}^n} v_l(u) \\
  v_l(u) = K^{-1} \dot{u} D_l(u) \\
  v_r(u') = K^{-1} \dot{u}'' D_r(u') \\
  u' = \pi (K \hat{v_l}(u))
\end{cases}&lt;/script&gt;

    &lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\Omega&lt;/script&gt; is the set of all valid pixels in the live depth map; 
&lt;script type=&quot;math/tex&quot;&gt;\psi&lt;/script&gt; is a robust Huber penalty function; 
&lt;script type=&quot;math/tex&quot;&gt;v_r(u')&lt;/script&gt; is the projectively data associated predicted vertex; 
&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x} \in \mathbb{R}^6&lt;/script&gt; is the parameterised incremental update &lt;script type=&quot;math/tex&quot;&gt;\tilde{T_{rl}^n} \in \mathrm{\boldsymbol{SE}(3)}&lt;/script&gt; (&lt;script type=&quot;math/tex&quot;&gt;\tilde{T_{rl}^{n=0}}&lt;/script&gt; is the identity); 
&lt;script type=&quot;math/tex&quot;&gt;K&lt;/script&gt; is the camera intrinsic matrix; and &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt; is standard pin-hole projection function.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Gauss-Newton based gradient descent&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
  \underset{u \in \Omega}{\sum} J(u)^T J(u) \boldsymbol{x} = \underset{u \in \Omega}{\sum} \psi'(e) J(u) \\
  J(u) = \frac{\partial e(\boldsymbol{x},u)}{\partial \boldsymbol{x}}
\end{cases}&lt;/script&gt;

    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\psi'&lt;/script&gt; computes the robust penalty function derivative given currently estimated error.&lt;/p&gt;

    &lt;p&gt;Solve for the optimal &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{x}&lt;/script&gt; and compute current pose after m incremental updates by:&lt;/p&gt;

    &lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
  \tilde{T_{rl}^{n+1}} \leftarrow exp(\boldsymbol{x})\tilde{T_{rl}^n} \\
  T_{wl} \leftarrow T_{wr} \tilde{T_{rl}^m} 
\end{cases}&lt;/script&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;reference&quot;&gt;Reference:&lt;/h3&gt;

&lt;p&gt;[1] 高翔；张涛；刘毅；严沁睿: “视觉SLAM十四讲，从理论到实践”.&lt;/p&gt;

&lt;p&gt;[2] F. Pomerleau, F. Colas, and R. Siegwart. “A Review of Point Cloud Registration Algorithms for Mobile Robotics”. Foundations and Trends in Robotics. 4 (1): 1–104, 2015.&lt;/p&gt;

&lt;p&gt;[3] K. S. Arun, T. S. Huang, and S. D. Blostein. “Least-Squares Fitting of Two 3-D Point Sets”. Pattern Analysis and Machine Intelligence, IEEE Transactions on, 9(5):698–700, 1987.&lt;/p&gt;

&lt;p&gt;[4] S. Rusinkiewicz and M. Levoy. “Efficient Variants of the ICP Algorithm”. In Proceedings of the IEEE International Workshop on 3D Digital Imaging and Modeling (3DIM), 2001.&lt;/p&gt;

&lt;p&gt;[5] R. F. Salas-Moreno, R. A. Newcombe, H. Strasdat, P. H. Kelly, and A. J. Davison, “SLAM++: Simultaneous localisation and mapping at the level of objects”. Computer Vision and Pattern Recognition (CVPR), 2013 IEEE Conference on. IEEE, 2013, pp. 1352–1359.&lt;/p&gt;

&lt;h3 id=&quot;appendix&quot;&gt;Appendix&lt;/h3&gt;
&lt;p&gt;1.&lt;/p&gt;

&lt;p&gt;From eigenvalues decomposition to sigular values decomposition:&lt;/p&gt;

&lt;p&gt;&lt;u&gt; *Eigenvalues* &lt;/u&gt;:&lt;/p&gt;

&lt;p&gt;By definition we have &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{A}\boldsymbol{v} = \lambda\boldsymbol{v}&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{A}&lt;/script&gt; must be a square matrix, &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{v}&lt;/script&gt; is an eigenvector with corresponding eigenvalue &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Putting all eigenvalues and eigenvectors into matrix form, we have&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{A} \boldsymbol{Q} = \boldsymbol{Q} \boldsymbol{\Sigma}&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{Q} = [\boldsymbol{v_1}, \boldsymbol{v_2}, \dots, \boldsymbol{v_n}]&lt;/script&gt; is an orthogonal matrix, &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{\Sigma} = diag(\lambda_1, \lambda_2, \dots, \lambda_n)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Leading to the eigenvalue decomposition:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{A} = \boldsymbol{Q} \boldsymbol{\Sigma} \boldsymbol{Q}^{-1} = \boldsymbol{Q} \boldsymbol{\Sigma} \boldsymbol{Q}^T&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;u&gt; *SVD* &lt;/u&gt;:&lt;/p&gt;

&lt;p&gt;Going beyond square matrices, for any matrix &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{A}&lt;/script&gt; of size &lt;script type=&quot;math/tex&quot;&gt;m \times n&lt;/script&gt;, the SVD can be done as &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{A_{m \times n}} = \boldsymbol{U_{m \times m}} \boldsymbol{\Sigma_{m \times n}} \boldsymbol{V_{n \times n}}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Reasoning with eigenvalues:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
    (\boldsymbol{A}^T\boldsymbol{A})\boldsymbol{v_i} = \lambda_i\boldsymbol{v_i} \\
    (\boldsymbol{A}\boldsymbol{A}^T)\boldsymbol{u_i} = \lambda_i\boldsymbol{u_i}
  \end{cases}&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{u_i}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{v_i}&lt;/script&gt; are columns of &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{U}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{V}&lt;/script&gt; respectively. Note that &lt;script type=&quot;math/tex&quot;&gt;\lambda_i&lt;/script&gt; in both equations have the same values.&lt;/p&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{A}&lt;/script&gt; has rank &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt;, i.e. there are &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; nonzero elements in the diagonal matrix &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{\Sigma}&lt;/script&gt; (&lt;script type=&quot;math/tex&quot;&gt;diag(\sigma_1, \dots, \sigma_r)&lt;/script&gt;), then:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{u_1}, \boldsymbol{u_2}, \dots, \boldsymbol{u_r}&lt;/script&gt; form a set of orthogonal basis for &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{A}&lt;/script&gt;;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{v_1}, \boldsymbol{v_2}, \dots, \boldsymbol{v_r}&lt;/script&gt; form a set of orthogonal basis for &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{A}^T&lt;/script&gt;.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To find sigular values, you can either:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\sigma_i = \boldsymbol{A}\boldsymbol{v_i} / \boldsymbol{u_i}&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\sigma_i = \sqrt{\lambda_i}&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;2.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{split}
    \sum_{i=1}^n \parallel \boldsymbol{p_i} - (\boldsymbol{R}\boldsymbol{p_i}' + \boldsymbol{t}) \parallel^2 
    &amp;= \sum_{i=1}^n \parallel (\boldsymbol{p_i} - \boldsymbol{p}) + \boldsymbol{p} - \boldsymbol{R} ( \boldsymbol{p_i}' - \boldsymbol{p}' ) - \boldsymbol{R}\boldsymbol{p}' -\boldsymbol{t} \parallel^2 \\
    &amp;= \sum_{i=1}^n \parallel (\boldsymbol{p_i} - \boldsymbol{p}  - \boldsymbol{R} ( \boldsymbol{p_i}' - \boldsymbol{p}' ) ) + (\boldsymbol{p} - \boldsymbol{R}\boldsymbol{p}' -\boldsymbol{t}) \parallel^2 \\
    &amp;= \sum_{i=1}^n \parallel \boldsymbol{p_i} - \boldsymbol{p}  - \boldsymbol{R} ( \boldsymbol{p_i}' - \boldsymbol{p}' ) \parallel^2 + \sum_{i=1}^n \parallel \boldsymbol{p} - \boldsymbol{R}\boldsymbol{p}' -\boldsymbol{t} \parallel^2 - 2 \sum_{i=1}^n (\boldsymbol{p_i} - \boldsymbol{p}  - \boldsymbol{R} ( \boldsymbol{p_i}' - \boldsymbol{p}' ))^T (\boldsymbol{p} - \boldsymbol{R}\boldsymbol{p}' -\boldsymbol{t})
  \end{split} %]]&gt;&lt;/script&gt;

&lt;p&gt;By the definition of the centroids, we can find that &lt;script type=&quot;math/tex&quot;&gt;\sum_{i=1}^n \boldsymbol{p_i} - \boldsymbol{p}  - \boldsymbol{R} ( \boldsymbol{p_i}' - \boldsymbol{p}' ) = 0&lt;/script&gt;. Therefore, we have:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^n \parallel \boldsymbol{p_i} - (\boldsymbol{R}\boldsymbol{p_i}' + \boldsymbol{t}) \parallel^2 = \sum_{i=1}^n \parallel \boldsymbol{p_i} - \boldsymbol{p} - \boldsymbol{R}(\boldsymbol{p_i}' - \boldsymbol{p}') \parallel^2 + \parallel \boldsymbol{p} - \boldsymbol{R}\boldsymbol{p}' - \boldsymbol{t} \parallel^2&lt;/script&gt;

&lt;p&gt;3.&lt;/p&gt;

&lt;p&gt;Assume that &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{v_i} = \boldsymbol{R}\boldsymbol{q_i}'&lt;/script&gt;, we have&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^n \boldsymbol{q_i}^T \boldsymbol{R} \boldsymbol{q_i}' = \sum_{i=1}^n \boldsymbol{q_i}^T \boldsymbol{v_i}&lt;/script&gt;

&lt;p&gt;Additionally, assume that &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{q_i} = (x_i, y_i, z_i)^T&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{v_i} = (a_i, b_i, c_i)^T&lt;/script&gt;, we have&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{split}
    \sum_{i=1}^n \boldsymbol{q_i}^T \boldsymbol{v_i} 
    &amp;= \sum_{i=1}^n (x_i, y_i, z_i)(a_i, b_i, c_i)^T \\
    &amp;= \sum_{i=1}^n x_ia_i + y_ib_i + z_ic_i \\
    &amp;= \sum_{i=1}^n tr(
    \begin{pmatrix}
      x_ia_i &amp; \dots &amp; \dots \\
      \dots &amp; y_ib_i &amp; \dots \\
      \dots &amp; \dots &amp; z_ic_i
    \end{pmatrix}
    ) \\
    &amp;= \sum_{i=1}^n tr(\boldsymbol{v_i} \boldsymbol{q_i}^T) \\
    &amp;= tr(\sum_{i=1}^n \boldsymbol{v_i} \boldsymbol{q_i}^T ) \\
    &amp;= tr(\sum_{i=1}^n \boldsymbol{R} \boldsymbol{q_i}' \boldsymbol{q_i}^T) \\
    &amp;= tr(\boldsymbol{R} \sum_{i=1}^n \boldsymbol{q_i}' \boldsymbol{q_i}^T) 
  \end{split} %]]&gt;&lt;/script&gt;

&lt;p&gt;4.&lt;/p&gt;

&lt;p&gt;Quote from [3]:&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;u&gt;Lemma&lt;/u&gt;: For any positive definite matrix &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{A}&lt;/script&gt;, and any orthonomal matrix &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{B}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;tr(\boldsymbol{A}) \geq tr(\boldsymbol{B}\boldsymbol{A})&lt;/script&gt;.&lt;/p&gt;

  &lt;p&gt;&lt;u&gt;Proof of Lemma refer to [3], using Schwarz inequality&lt;/u&gt;.&lt;/p&gt;

  &lt;p&gt;Let the SVD of H be &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{H} = \boldsymbol{U}\boldsymbol{\Sigma}\boldsymbol{V}^T&lt;/script&gt;,&lt;/p&gt;

  &lt;p&gt;and &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{X} = \boldsymbol{V}\boldsymbol{U}^T&lt;/script&gt;.&lt;/p&gt;

  &lt;p&gt;So, we have&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol{X}\boldsymbol{H} = \boldsymbol{V} \boldsymbol{U}^T \boldsymbol{U} \boldsymbol{\Sigma} \boldsymbol{V}^T = \boldsymbol{V} \boldsymbol{\Sigma} \boldsymbol{V}^T&lt;/script&gt;

  &lt;p&gt;which is symmetrical and positive definite. Using the Lemma above, for any orthonormal matrix &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{B}&lt;/script&gt;,&lt;/p&gt;

  &lt;script type=&quot;math/tex; mode=display&quot;&gt;tr(\boldsymbol{X}\boldsymbol{H}) \geq tr(\boldsymbol{B}\boldsymbol{X}\boldsymbol{H})&lt;/script&gt;

  &lt;p&gt;i.e. among all 3x3 orthonomal matrices, &lt;script type=&quot;math/tex&quot;&gt;\boldsymbol{X}&lt;/script&gt; maximizes &lt;script type=&quot;math/tex&quot;&gt;tr(\boldsymbol{R} \sum_{i=1}^n \boldsymbol{q_i}' \boldsymbol{q_i}^T) = \sum_{i=1}^n \boldsymbol{q_i}^T \boldsymbol{R} \boldsymbol{q_i}'&lt;/script&gt;。&lt;/p&gt;

  &lt;p&gt;By definition, rotation matrices are special orthogonal matrices, thus &lt;script type=&quot;math/tex&quot;&gt;det(\boldsymbol{X}) = 1&lt;/script&gt;. It is a reflection matrix if &lt;script type=&quot;math/tex&quot;&gt;det(\boldsymbol{X}) = -1&lt;/script&gt;.&lt;/p&gt;
&lt;/blockquote&gt;</content><author><name>Yuhang Ming</name><email>yuhang.ming@bristol.ac.uk</email></author><summary type="html">Usage:</summary></entry><entry><title type="html">Example content</title><link href="http://localhost:4000/example/" rel="alternate" type="text/html" title="Example content" /><published>2017-01-31T11:00:09+00:00</published><updated>2017-01-31T11:00:09+00:00</updated><id>http://localhost:4000/example</id><content type="html" xml:base="http://localhost:4000/example/">&lt;h1 id=&quot;h1---a-first-level-header&quot;&gt;H1 - A First Level Header&lt;/h1&gt;

&lt;h2 id=&quot;h2--a-second-level-header&quot;&gt;H2- A Second Level Header&lt;/h2&gt;

&lt;h3 id=&quot;h3---a-third-level-header&quot;&gt;H3 - A Third Level Header&lt;/h3&gt;

&lt;h4 id=&quot;h4---a-fourth-level-header&quot;&gt;H4 - A Fourth Level Header&lt;/h4&gt;

&lt;h5 id=&quot;h5---a-fifth-level-header&quot;&gt;H5 - A Fifth Level Header&lt;/h5&gt;

&lt;h6 id=&quot;h6---a-sixed-level-header&quot;&gt;H6 - A Sixed Level Header&lt;/h6&gt;

&lt;p&gt;Text can be &lt;strong&gt;bold&lt;/strong&gt;, &lt;em&gt;italic&lt;/em&gt;, or  &lt;s&gt;strikethrough&lt;/s&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;#&quot;&gt;Links&lt;/a&gt; are blue with underline. When they hover over, the color changes to dark blue&lt;/p&gt;

&lt;p&gt;There should be white spaces between paragraphs. There should be white spaces between paragraphs.
There should be white spaces between paragraphs. There should be white spaces between paragraphs.&lt;/p&gt;

&lt;p&gt;There should be white spaces between paragraphs. There should be white spaces between paragraphs. 
There should be white spaces between paragraphs. There should be white spaces between paragraphs.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&quot;blockquote&quot;&gt;Blockquote&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;This is a blockquote with two paragraphs. Lorem ipsum dolor sit amet,
consectetuer adipiscing elit. Aliquam hendrerit mi posuere lectus.
Vestibulum enim wisi, viverra nec, fringilla in, laoreet vitae, risus.&lt;/p&gt;

  &lt;p&gt;Donec sit amet nisl. Aliquam semper ipsum sit amet velit. Suspendisse
id sem consectetuer libero luctus adipiscing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;unordered-lists&quot;&gt;Unordered lists&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Blue&lt;/li&gt;
  &lt;li&gt;Green&lt;/li&gt;
  &lt;li&gt;Yellow&lt;/li&gt;
  &lt;li&gt;More colors:
    &lt;ul&gt;
      &lt;li&gt;Red&lt;/li&gt;
      &lt;li&gt;Orange&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Most useds:
    &lt;ol&gt;
      &lt;li&gt;Black&lt;/li&gt;
      &lt;li&gt;White&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ordered-lists&quot;&gt;Ordered lists&lt;/h3&gt;

&lt;ol&gt;
  &lt;li&gt;Blue&lt;/li&gt;
  &lt;li&gt;Green&lt;/li&gt;
  &lt;li&gt;Yellow&lt;/li&gt;
  &lt;li&gt;Red&lt;/li&gt;
  &lt;li&gt;More colors:
    &lt;ol&gt;
      &lt;li&gt;Orange&lt;/li&gt;
      &lt;li&gt;Pink&lt;/li&gt;
    &lt;/ol&gt;
  &lt;/li&gt;
  &lt;li&gt;Most useds:
    &lt;ul&gt;
      &lt;li&gt;Black&lt;/li&gt;
      &lt;li&gt;White&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;task-list&quot;&gt;Task List&lt;/h3&gt;

&lt;ul class=&quot;task-list&quot;&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Buy rice&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Buy beans&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; /&gt;Buy potato&lt;/li&gt;
  &lt;li class=&quot;task-list-item&quot;&gt;&lt;input type=&quot;checkbox&quot; class=&quot;task-list-item-checkbox&quot; disabled=&quot;disabled&quot; checked=&quot;checked&quot; /&gt;Buy noodles&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;tables&quot;&gt;Tables&lt;/h3&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Language&lt;/th&gt;
      &lt;th&gt;Code&lt;/th&gt;
      &lt;th&gt;Type&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;HTML&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;&amp;lt;p&amp;gt; Hello &amp;lt;/p&amp;gt;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Front End&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;CSS&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;p { color: blue; }&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Front End&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;JavaScript&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;var msg = &quot;Hello&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Front End&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;PHP&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;$msg = 'Hello';&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Back End&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;Python&lt;/td&gt;
      &lt;td&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;msg = &quot;Hello&quot;&lt;/code&gt;&lt;/td&gt;
      &lt;td&gt;Back End&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;code-blocks&quot;&gt;Code blocks&lt;/h3&gt;

&lt;p&gt;Here is an example of &lt;code class=&quot;highlighter-rouge&quot;&gt;Python&lt;/code&gt;:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-python&quot; data-lang=&quot;python&quot;&gt;&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;__name__&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'__main__'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;:&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img_thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;threading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;target&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;downloadWallpaper&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img_thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;st&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\r&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Downloading Image'&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;img_thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;is_alive&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;():&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;sys&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;stdout&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;write&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;st&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'.'&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;((&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;%&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;))&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;current&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;+&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;time&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mf&quot;&gt;0.3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;img_thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;join&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;print&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;'&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;Image of the day downloaded.'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;h3 id=&quot;images&quot;&gt;Images&lt;/h3&gt;

&lt;p&gt;Images are resized according to screen size.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;\assets\img\image-blog.png&quot; alt=&quot;Image&quot; /&gt;&lt;/p&gt;</content><author><name>Yuhang Ming</name><email>yuhang.ming@bristol.ac.uk</email></author><summary type="html">H1 - A First Level Header</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="http://localhost:4000/welcome-to-jekyll/" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2017-01-25T17:00:09+00:00</published><updated>2017-01-25T17:00:09+00:00</updated><id>http://localhost:4000/welcome-to-jekyll</id><content type="html" xml:base="http://localhost:4000/welcome-to-jekyll/">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><author><name>Yuhang Ming</name><email>yuhang.ming@bristol.ac.uk</email></author><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry></feed>